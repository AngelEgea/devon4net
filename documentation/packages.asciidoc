
:toc: 

= Packages

toc::[]

== Overview

Devon4Net is made up of several components, all of which are described in this document. This components are available in the form of NuGet packages. In the https://github.com/devonfw/devon4net[Devon4Net repository] this packages are placed in the Infrastructure layer which is a cross-cutting layer that can be referenced from any level on the architecture.

.Infrastructure directory
image::images/Infrastructure_package.png[]

Components are class librarys that collaborate with each other for a purpose. They group the necessary code so that they can work according to the specified configuration. For example, the package `Devon4Net.Infrastructure.Swagger` has isolated the swagger essential pieces of code and has been developed in such a manner that you just need to write a few lines and specify a couple options to get it working the way you need.

=== Component structure

All of the components follow a similar structure which includes the next directories:

* *Configuration:* Static configuration class (or multiple classes) that contains extension methods used to configure the component.
* *Handlers:* Classes that are required to manage complex operations or communications.
* *Helpers:* Normally static classes that help in small conversions and operations.
* *Constants:* Classes that contain static constants to get rid of hard-coded values.

NOTE: Because each component is unique, you may find some more directories or less than tose listed above.

== Configuration basics

Any configuration for .Net Core 6.0 projects needs to be done in the `Program.cs` files which is placed on the startup application, but we can extract any configuration needed to an extension method and call that method from the component. As a result, the component will group everything required and the configuration will be much easier.

=== Extension methods

https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods[Extension methods] allow you to "add" methods to existing types without having to create a new derived type, or modify it in any way. Although they are static methods, they are referred to as instance methods on the extended type. For C# code, there is no difference in calling a extension method and a method defined in a type.

For example, the next extension method will extend the class `ExtendedClass` and it will need an `OptionalParameter` instance to do some configuration:

[source, c#]
----
public static class ExtensionMethods
{
    public static void DoConfiguration(this ExtendedClass class,  OptionalParameter extra) 
    {
        // Do your configuration here
        class.DoSomething();
        class.AddSomething(extra)
    }
}
----

Thanks to the `this` modifier preceeding the first parameter, we are able to call the method directly on a instance of `ExtendedClass` as follows:

[source, c#]
----
ExtendedClass class = new();
OptionalParameter extra = new();

class.DoConfiguration(extra);
----

As you can see, we don't need that a class derived from `ExtendedClass` to add some methods and we don't need those methods placed in the class itself either. This can be seen easily when extending a primitive type such as `string`:

[source, c#]
----
public static class ExtensionMethods
{
    public static int CountWords(this string word,  char[] separationChar = null) 
    {
        if(separationChar == null) separationChar = new char[]{' '};
        return word.Split(separationChar, StringSplitOptions.RemoveEmptyEntries).Length;
    }
}
----

In the previous example we created a method that can count words given a list of separation characters. And now we can use it over any string as follows:

[source, c#]
----
string s = "Hello World";
Console.WriteLine(s.CountWords());
----
[source, output]
----
2
----

NOTE: Remember to reference the class so you can use the extension methods (`using` directive).

=== Options pattern

The https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration/options?view=aspnetcore-6.0[options design pattern] allows you to have strong typed options and provides you the ability to inject them into your services. To follow this pattern, the configuration present on the `appsettings.json` needs to be mapped into an object.

This means, the following configuration:
[source, json]
----
"essentialoptions" : {
  "value1": "Hello",
  "value2": "World"
}
----

Would need the following class:
[source, c#]
----
public class EssentialOptions 
{
    public string Value1 { get; set; }
    public string Value2 { get; set; }
}
----

In .Net we can easily map the configuration thanks to the `Configure<T>()` method from `IServiceCollection` and `GetSection()` method from `IConfiguration`. We could be loading the configuration as follows:

[source, c#]
----
services.Configure<EssentialOptions>(configuration.GetSection("essentialoptions"));
----

And then injecting it making use of `IOptions<T>` interface:
[source, c#]
----
public class MyService : IMyService
{
    private readonly EssentialOptions _options;

    public MyService(IOptions<EssentialOptions> options) 
    {
        _options = options.Value;
    }
}
----

In devon4net, there is an `IServiceCollection` extension available that uses the methods described above and also returns the options injected thanks to `IOptions<T>`.  So, to load the same options, we should use the following:

[source, c#]
----
EssentialOptions options = services.GetTypedOptions<EssentialOptions>(configuration, "essentialoptions");
----

=== Dependency Injection

https://docs.microsoft.com/en-us/dotnet/core/extensions/dependency-injection[Dependency Injection] is a technique for achieving Inversion of Control Principle. In .Net it is a built-in part that comes with the framework.

Using a service provider `IServiceProvider` available in .Net, we are able to add any service or option to a service stack that will be available for injection in constructors of the classes where it's used.

Services can be registered with one of the following lifetimes:
|=====
|*Lifetime* | *Description* |*Example*
|Transient |Transient lifetime services are created each time they're requested from the service container. Disposed at the end of the request. |services.AddTransient<IDependency, Dependency>();
|Scoped |A scoped lifetime indicates that services are created once per client request (connection).  Disposed at the end of the request. |services.AddScoped<IDependency, Dependency>();
|Singleton |Singleton lifetime services are created either the first time they're requested or by the developer. Every subsequent request of the service implementation from the dependency injection container uses the same instance. |services.AddSingleton<IDependency, Dependency>();
|=====

This injections would be done in the startup project in `Program.cs` file, and then injected in constructors where needed.

== Devon4Net.Infrastructure.CircuitBreaker

The Devon4Net.Infrastructure.CircuitBreaker component implements the retry pattern for HTTP/HTTPS calls. It may be used in both SOAP and REST services. 

=== Configuration

Component configuration is made on file `appsettings.{environment}.json` as follows:

[source, json]
----
"CircuitBreaker": {
    "CheckCertificate": false,
    "Endpoints": [
      {
        "Name": "SampleService",
        "BaseAddress": "http://localhost:5001",
        "Headers": {
        },
        "WaitAndRetrySeconds": [
          0.0001,
          0.0005,
          0.001
        ],
        "DurationOfBreak": 0.0005,
        "UseCertificate": false,
        "Certificate": "localhost.pfx",
        "CertificatePassword": "localhost",
        "SslProtocol": "Tls12", //Tls, Tls11,Tls12, Tls13, none
        "CompressionSupport": true,
        "AllowAutoRedirect": true
      }
    ]
  }
----
[options="header"]
|=======================
|*Property*|*Description*
|`CheckCertificate`| True if HTTPS is required. This is useful when developing an API Gateway needs a secured HTTP, disabling this on development we can use communications with a valid server certificate
|Endpoints| Array with predefined sites to connect with
|Name| The name key to identify the destination URL
|Headers| Not ready yet
|WaitAndRetrySeconds| Array which determines the number of retries and the lapse period between each retry. The value is in milliseconds.
|Certificate| Ceritificate client to use to perform the HTTP call
|CertificatePassword| The password that you assign when exporting the certificate
|`SslProtocol`| The secure protocol to use on the call

|=======================

==== Protocols
[options="header"]
|=======================
|*Protocol*|*Key*|*Description*
|SSl3|48| Specifies the Secure Socket Layer (SSL) 3.0 security protocol. SSL 3.0 has been superseded by the Transport Layer Security (TLS) protocol and is provided for backward compatibility only.
|TLS|192|Specifies the Transport Layer Security (TLS) 1.0 security protocol. The TLS 1.0 protocol is defined in IETF RFC 2246.
|TLS11|768| Specifies the Transport Layer Security (TLS) 1.1 security protocol. The TLS 1.1 protocol is defined in IETF RFC 4346. On Windows systems, this value is supported starting with Windows 7.
|TLS12|3072| Specifies the Transport Layer Security (TLS) 1.2 security protocol. The TLS 1.2 protocol is defined in IETF RFC 5246. On Windows systems, this value is supported starting with Windows 7.
|TLS13|12288| Specifies the TLS 1.3 security protocol. The TLS protocol is defined in IETF RFC 8446.

|=======================

=== Setting up in Devon

For setting it up using the Devon4NetApi template just configure it in the `appsettings.Development.json` file.

Add it using Dependency Injection on this case we instanciate Circuit Breaker in a Service Sample Class

[source, C#]
----
public class SampleService: Service<SampleContext>, ISampleService
    {
        private readonly ISampleRepository _sampleRepository;
        private IHttpClientHandler _httpClientHandler { get; }

        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="uoW"></param>
        public SampleService(IUnitOfWork<SampleContext> uoW, IHttpClientHandler httpClientHandler) : base(uoW)
        {
            _httpClientHandler = httpClientHandler;
            _sampleRepository = uoW.Repository<ISampleRepository>();
        }
    }    
----

Add the necessary references. 

[source, C#]
----
using Devon4Net.Infrastructure.CircuitBreaker.Common.Enums;
using Devon4Net.Infrastructure.CircuitBreaker.Handlers;
----

You must give the following arguments to make a POST call:

[source, C#]
----
await _httpClientHandler.Send<YourOutPutClass>(HttpMethod.POST, NameOfTheService, EndPoint, InputData, MediaType.ApplicationJson);    
----

Where:

[options="header"]
|=======================
|*Property*|*Description*
|YourOutputClass| The type of the class that you are expecting to retrieve from the call 
|NameOftheService| The key name of the endpoint provided in the appsettings.json file at Endpoints[] node
|`EndPoint`|Part of the url to use with the base address. E.g: _/validate_
|`InputData`| Your instance of the class with values that you want to use in the call
|`MediaType.ApplicationJson`| The media type flag for the call
|=======================


=== Setting up in other projects

Install the package on your solution using the Package Manager Console:

[source]
----
Install-Package Devon4Net.Infrastructure.CircuitBreaker
----

next add via Dependency Injection the circuit breaker instance.On this case we use a Service

[source, C#]
----
public class SampleService : ISampleService
 {
   private IHttpClientHandler _httpClientHandler { get; }

    public SampleService(IHttpClientHandler httpClientHandler)
      {
        _httpClientHandler = httpClientHandler;
      }
 }
----

Don't forget to provide the necessary references. 

[source, C#]
----
using Devon4Net.Infrastructure.CircuitBreaker.Common.Enums;
using Devon4Net.Infrastructure.CircuitBreaker.Handlers;
----

And configure CircuitBreaker in `Program.cs` adding the following lines:

[source, C#]
----
using Devon4Net.Infrastructure.CircuitBreaker;
.
.
.
builder.Services.SetupCircuitBreaker(builder.Configuration);
----

You must add the default configuration shown in the configuration section and at this point you can use the circuit breaker functionality in your code.

To perform a GET call you should use your circuit breaker instance as follows:

[source, C#]
----
await _httpClientHandler.Send<YourOutPutClass>(HttpMethod.Get, NameOfTheService, EndPoint, InputData, MediaType.ApplicationJson);    
----

Where:

[options="header"]
|=======================
|*Property*|*Description*
|YourOutputClass| The type of the class that you are expecting to retrieve from the call 
|NameOftheService| The key name of the endpoint provided in the appsettings.json file at Endpoints[] node
|`EndPoint`|Part of the url to use with the base address. E.g: _/validate_
|`InputData`| Your instance of the class with values that you want to use in the call
|`MediaType.ApplicationJson`| The media type flag for the call
|=======================

== Devon4Net.Infrastructure.Swagger

Swagger is a set of open source software tools for designing, building, documenting, and using RESTful web services. This component provides a full externalized configuration for the Swagger tool. 

It primarily provides the swagger UI for visualizing and testing APIs, as well as automatic documentation generation via annotations in controllers.

=== Configuration

Component configuration is made on file `appsettings.{environment}.json` as follows:

[source, json]
----
"Swagger": {
    "Version": "v1",
    "Title": "My Swagger API",
    "Description": "Swagger API for devon4net documentation",
    "Terms": "https://www.devonfw.com/terms-of-use/",
    "Contact": {
      "Name": "devonfw",
      "Email": "sample@mail.com",
      "Url": "https://www.devonfw.com"
    },
    "License": {
      "Name": "devonfw - Terms of Use",
      "Url": "https://www.devonfw.com/terms-of-use/"
    },
    "Endpoint": {
      "Name": "V1 Docs",
      "Url": "/swagger/v1/swagger.json",
      "UrlUi": "swagger",
      "RouteTemplate": "swagger/v1/{documentName}/swagger.json"
    }
},
----

In the following list all the configuration fields are described:

* `Version`: Actual version of the API.
* `Title`: Title of the API.
* `Description`: Description of the API.
* `Terms`: Link to the terms and conditions agreement.
* `Contact`: Your contact information.
* `License`: Link to the License agreement.
* `Endpoint`: Swagger endpoints information.

=== Setting up in Devon
For setting it up using the Devon4NetApi template just configure it in the `appsettings.{environment}.json` file.


=== Setting up in other projects
Install the package on your solution using the Package Manager Console:

[source, console]
----
> install-package Devon4Net.Infrastructure.Swagger
----

Configure swagger in `Program.cs` adding the following lines:

[source, c#]
----
using Devon4Net.Infrastructure.Swagger;
.
.
.
builder.Services.SetupSwagger(builder.Configuration);
.
.
.
app.ConfigureSwaggerEndPoint();
----

Add the default configuration shown in the configuration section.

=== Tips

* In order to generate the documentation annotate your actions with summary, remarks and response tags:
[source, c#]
----
/// <summary>
/// Method to make a reservation with potential guests. The method returns the reservation token.
/// </summary>
/// <param name="bookingDto"></param>
/// <response code="201">Ok.</response>
/// <response code="400">Bad request. Parser data error.</response>
/// <response code="401">Unauthorized. Authentication fail.</response>
/// <response code="403">Forbidden. Authorization error.</response>
/// <response code="500">Internal Server Error. The search process ended with error.</response>
[HttpPost]
[HttpOptions]
[Route("/mythaistar/services/rest/bookingmanagement/v1/booking")]
[AllowAnonymous]
[EnableCors("CorsPolicy")]
public async Task<IActionResult> Booking([FromBody]BookingDto bookingDto)
{
    try
    {

    ...
----
* You can access the swagger UI on `http://localhost:yourport/swagger/index.html`

== Devon4Net.Infrastructure.Logger

Previously known as Devon4Net.Infrastructure.Log(v5.0 or lower)

Logging is an essential component of every application's life cycle.
A strong logging system becomes a critical component that assists developers to understand and resolve emerging problems. 

NOTE: Starting with .NET 6, logging services no longer register the ILogger type. When using a logger, specify the generic-type alternative ILogger<TCategoryName> or register the `ILogger` with dependency injection (DI).

Default .Net log levels system: 

|=======================
|*Type*|*Description*
|Critical| Used to notify failures that force the program to shut down  
|Error| Used to track major faults that occur during program execution 
|Warning| Used to report non-critical unexpected behavior
|Information| Informative messages
|Debug| Used for debugging messages containing additional information about application operations 
|Trace| For tracing the code
|None| If you choose this option the loggin category will not write any messages
|=======================

=== Configuration

Component setup is done in the `appsettings.{environment}.json` file using the following structure:

[source, json]
----
  "Logging": {
    "UseLogFile": true,
    "UseSQLiteDb": true,
    "UseGraylog": true,
    "UseAOPTrace": false,
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    },
    "SqliteDatabase": "logs/log.db",
    "LogFile": "logs/{0}_devonfw.log",
    "SeqLogServerHost": "http://127.0.0.1:5341",
    "GrayLog": {
      "GrayLogHost": "127.0.0.1",
      "GrayLogPort": "12201",
      "GrayLogProtocol": "UDP",
      "UseSecureConnection": true,
      "UseAsyncLogging": true,
      "RetryCount": 5,
      "RetryIntervalMs": 15,
      "MaxUdpMessageSize": 8192
    }
  }
----

Where:

* `UseLogFile`: When you set this option to true, you can store the log output to a file.  
* `UseSQLiteDb`: True when you wish to insert the log output into a SQLiteDb
* `UseGrayLog`: This option enables the use of GrayLog for loggin
* `UseAOPTrace`: True if you need to trace the attributes of the controllers

WARNING: Don't set to true on production environments, doing so may expose critical information. 

* `LogLevel`: Sets the minimum level of logs to be captured
* `SqliteDatabase`: path to SQlite database 
* `LogFile`: path to the log file
* `SeqLogServerHost`: url for Seq server, you need to install Seq  in order to use it, you can install it clicking https://datalust.co/download[here]
* `GrayLog`: Some configuration parameters for Graylog service you can install it using https://www.graylog.org/products/open-source#download-open[this link] 


=== Setting up in Devon

For setting it up using the Devon4NetApi template just configure it in the `appsettings.Development.json` file.

You can use the methods implemented in Devon4NetLogger class, each method corresponds with a log level in .Net log levels system, for example:

[source, c#]
----
Devon4NetLogger.Debug("Executing GetTodo from controller TodoController");
----


=== Setting up in other projects

Install the package on your solution using the Package Manager Console:

[source, console]
----
> install-package Devon4Net.Infrastructure.Logger
----

Add the following line of code to Progam.cs: 

[source, c#]
----
builder.Services.SetupLog(builder.Configuration);
----

Add the default configuration shown in the configuration section.

use the Devon4NetLogger class methods as explanied above:

[source, c#]
----
Devon4NetLogger.Information("Executing GetSample from controller SampleController");
----


== Devon4Net.Infrastructure.Cors

Allows CORS settings for the devon4Net application.
Configuration may be used to configure several domains.
Web clients (for example, Angular) must follow this rule to avoid performing AJAX calls to another domain. 

Cross-Origin Resource Sharing (CORS) is an HTTP-header-based mechanism that allows a server to specify any origin (domain, scheme, or port) outside of its own from which a browser should allow resources to be loaded. CORS also makes use of a process in which browsers send a "preflight" request to the server hosting the cross-origin resource to ensure that the server will allow the actual request. During that preflight, the browser sends headers indicating the HTTP method as well as headers that will be used in the actual request.

You may find out more by going to https://docs.microsoft.com/es-es/aspnet/core/security/cors?view=aspnetcore-6.0[Microsoft CORS documentation]

=== Configuration

Component setup is done in the `appsettings.{environment}.json` file using the following structure:

[source, json]
----
 "Cors": //[], //Empty array allows all origins with the policy "CorsPolicy"
  [
    {
      "CorsPolicy": "CorsPolicy",
      "Origins": "http://localhost:4200,https://localhost:4200,http://localhost,https://localhost;http://localhost:8085,https://localhost:8085",
      "Headers": "accept,content-type,origin,x-custom-header,authorization",
      "Methods": "GET,POST,HEAD,PUT,DELETE",
      "AllowCredentials": true
    }
  ]
----

You may add as many policies as you like following the JSON format. for example:

[source, json]
----
 "Cors": //[], //Empty array allows all origins with the policy "CorsPolicy"
  [
    {
      "CorsPolicy": "FirstPolicy",
      "Origins": "http://localhost:4200",
      "Headers": "accept,content-type,origin,x-custom-header,authorization",
      "Methods": "GET,POST,DELETE",
      "AllowCredentials": true
    },
    {
      "CorsPolicy": "SecondPolicy",
      "Origins": "https://localhost:8085",
      "Headers": "accept,content-type,origin",
      "Methods": "GET,POST,HEAD,PUT,DELETE",
      "AllowCredentials": false
    }
  ]
----

In the following table all the configuration fields are described:

|=======================
|*Property*|*Description*
|CorsPolicy| Name of the policy
|Origins| The origin's url that you wish to accept.
|Headers| Permitted request headers
|Methods| Allowed Http methods
|AllowCredentials| Set true to allow the exchange of credentials across origins
|=======================

=== Setting up in Devon

For setting it up using the Devon4NetApi template just configure it in the `appsettings.Development.json` file.

You can enable CORS per action, per controller, or globally for all Web API controllers in your application:

* Add this annotation in the Controller Class you want to use CORS policy
+
[source, c#]
----
[EnableCors("CorsPolicy")]
----
+
As an example, consider this implementation on the EmployeeController class
+
[source, c#]
----
namespace Devon4Net.Application.WebAPI.Implementation.Business.EmployeeManagement.Controllers
{
    /// <summary>
    /// Employees controller
    /// </summary>
    [ApiController]
    [Route("[controller]")]
    [EnableCors("CorsPolicy")]
    public class EmployeeController: ControllerBase
    {
      .
      .
      .
    }
}
----
+
The example above enables CORS for all the controller methods.

* In the same way, you may enable CORS on any controller method:
+
[source, c#]
----
[EnableCors("FirstPolicy")]
public async Task<ActionResult> GetEmployee()
{

}
        
public async Task<ActionResult> ModifyEmployee(EmployeeDto employeeDto) 
{

}

[EnableCors("SecondPolicy")]        
public async Task<ActionResult> Delete([Required]long employeeId)
{

}
----
+
The example above enables CORS for the GetEmployee and Delete method. 

=== Setting up in other projects

Using the Package Manager Console, install the the next package on your solution: 

[source, console]
----
> install-package Devon4Net.Infrastructure.Cors
----

Add the following lines of code to Progam.cs: 

[source, c#]
----
builder.Services.SetupCors(builder.Configuration);
.
.
.
app.SetupCors();
----

Add the default configuration shown in the configuration section.

You can enable CORS per action, per controller, or globally for all Web API controllers in your application:

* Add this annotation to the controller class that will be using the CORS policy. 
+
[source, c#]
----
[EnableCors("SamplePolicy")]
    public class SampleController: ControllerBase
    {
      .
      .
      .
    }
----
+
Where "SamplePolicy" is the name you give the Policy in the `appsettings.{environment}.json`.
+
The example above enables CORS for all the controller methods.

* In the same way, you may enable any CORS-policy on any controller method:
+
[source, c#]
----
[EnableCors("FirstPolicy")]
public async Task<ActionResult> GetSample()
{

}
        
public async Task<ActionResult> Modify(SampleDto sampleDto)
{

} 

[EnableCors("SecondPolicy")]        
public async Task<ActionResult> Delete([Required]long sampleId)
{

}
----
+
The example above enables CORS for the GetSample and Delete method. 

=== Tips

* If you specify the CORS in the `appsettings.{environment}.json` configuration file as empty array, a default CORS-policy will be used with all origins enabled:

[source, json]
----
 "Cors": [], //Empty array allows all origins with the policy "CorsPolicy" 
----

WARNING: Only use this policy in development environments

This default CORS-policy is defined as "CorsPolicy," and it should be enabled on the Controller Class as a standard Policy:

[source, c#]
----
[EnableCors("CorsPolicy")] 
public IActionResult Index() {  
    return View();  
}  
----

* if you want to disable the CORS check use the following annotation on any controller method:

[source, c#]
----
[DisableCors]
public IActionResult Index() {
    return View();
}
----

* If you set the EnableCors attribute at more than one scope, the order of precedence is:

1. Action
2. Controller
3. Global

== Devon4Net.Infrastructure.JWT
"JSON Web Token (JWT) is an open standard (https://datatracker.ietf.org/doc/html/rfc7519[RFC 7519]) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object. This information can be verified and trusted because it is digitally signed. JWTs can be signed using a secret (with the `HMAC` algorithm) or a public/private key pair using `RSA` or `ECDSA` ."
-- https://jwt.io/introduction/[What is JSON Web Token?]

In other words, a JSON Web Token is a JSON object encoded into an encrypted `string` that can be decoded and verified making use of cryptographic methods and algorithms. This tokens are mostly used to authenticate users in the context of websites, web applications and web services, but they can also be used to securely exchange information between parties.

=== Configuration
Component configuration is made on file `appsettings.{environment}.json` as follows:

[source, json]
----
"JWT": {
    "Audience": "devon4Net",
    "Issuer": "devon4Net",
    "ValidateIssuerSigningKey": true,
    "ValidateLifetime": true,
    "RequireSignedTokens": true,
    "RequireExpirationTime": true,
    "RequireAudience": true,
    "ClockSkew": 5,
    "Security": {
      "SecretKeyEncryptionAlgorithm": "",
      "SecretKey": "",
      "Certificate": "",
      "CertificatePassword": "",
      "CertificateEncryptionAlgorithm": "",
      "RefreshTokenEncryptionAlgorithm": ""
    }
  },
----

In the following list all the configuration fields are described:

* `Audience`: Represents a valid audience that will be used to check against the token's audience.
* `Issuer`: Represents a valid issuer that will be used to check against the token's issuer.
//* `TokenExpirationTime`: -------
* `ValidateIssuerSigningKey`: Boolean that controls if validation of the SecurityKey that signed the securityToken is called.
* `ValidateLifetime`: Boolean to control if the lifetime will be validated during token validation.
* `RequireSignedTokens`: Boolean that indicates wether a security token has to be signed oe not.
* `RequireExpirationTime`: Boolean that tells the handler if tokens need an expiration time specified or not.
* `RequireAudience`: Boolean that indicates tokens need to have an audience specified to be valid or not.
* `ClockSkew`: Expiration time in minutes.
* `Security`: Certificate properties will be found in this part.
** `SecretKeyEncryptionAlgorithm`: Algorithm used to encrypt the secret key. If no argument is specified, `HmacSha512` is used.
** `SecretKey`: Private key used to sign with the certificates. This key will be encrypted and hashed using the specified algorithm.
** `Certificate`: Name of certificate file or its path (if it is not in the same directory). If it doesn't exist an exception will be raised.
** `CertificatePassword`: Password for the certificate selected.
** `CertificateEncryptionAlgorithm`: Algorithm used to encrypt the certificate. If no argument is specified, `HmacSha512` is used.
** `RefreshTokenEncryptionAlgorithm`: Algorithm used to encrypt the refresh token. If no argument is specified, `HmacSha512` is used.

There are two ways of using and creating tokens:

* Secret key: A key to encrypt and decrypt the tokens is specified. This key will be encrypted using the specified algorithm.
* Certificates: A certificate is used to manage token encryption and decryption.

NOTE: Because the secret key takes precedence over the other option, JWT with the secret key will be used if both configurations are supplied.

==== Encryption algorithms

The supported and tested algorithms are the following:

|=======================
|*Algorithm* |*Value*
|`HmacSha256` | HS256
|`HmacSha384` | HS384
|`HmacSha512` | HS512
|`HmacSha256Signature` | http://www.w3.org/2001/04/xmldsig-more#hmac-sha256
|`HmacSha384Signature` | http://www.w3.org/2001/04/xmldsig-more#hmac-sha384
|`HmacSha512Signature` | http://www.w3.org/2001/04/xmldsig-more#hmac-sha512
|=======================

For the refresh token encryption algorithm you will be able to use any algoritm from the previous table and the following table:

|=======================
|*Algorithm* |*Value*
|`MD5` | MD5
|`Sha` | SHA
|=======================

NOTE: You will need to specify the name of the algorithm (shown in 'algorithm' column) when configuring the component.

////
*RSA*
|=======================
|*Algorithm*|*Value*
|`RsaSha256` | RS256
|`RsaSha384` | RS384
|`RsaSha512` | RS512
|`RsaSha256Signature` | http://www.w3.org/2001/04/xmldsig-more#rsa-sha256
|`RsaSha384Signature` | http://www.w3.org/2001/04/xmldsig-more#rsa-sha384
|`RsaSha512Signature` | http://www.w3.org/2001/04/xmldsig-more#rsa-sha512
|`RsaOAEP` | RS-OAEP
|`RsaPKCS1` | RSA1_5
|`RsaOaepKeyWrap` | http://www.w3.org/2001/04/xmlenc#rsa-oaep
|=======================

*ECDsa*
|=======================
|*Algorithm*|*Value*
|`EcdsaSha256` | ES256
|`EcdsaSha384` | ES384
|`EcdsaSha512` | ES512
|`EcdsaSha256Signature` | http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha256
|`EcdsaSha384Signature` | http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha384
|`EcdsaSha512Signature` | http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha512
|=======================

*Hash*
|=======================
|*Algorithm*|*Value*
|`Sha256` | SHA256
|`Sha384` | SHA384
|`Sha512` | SHA512
|`Sha256Digest` | http://www.w3.org/2001/04/xmlenc#sha256
|`Sha384Digest` | http://www.w3.org/2001/04/xmldsig-more#sha384
|`Sha512Digest` | http://www.w3.org/2001/04/xmlenc#sha512
|=======================

*Symmetric*
|=======================
|*Algorithm*|*Value*
|`Aes128CbcHmacSha256` | A128CBC-HS256
|`Aes192CbcHmacSha384` | A192CBC-HS384
|`Aes256CbcHmacSha512` | A256CBC-HS512
|`Aes128KW` | A128KW
|`Aes256KW` | A256KW
|`HmacSha256` | HS256
|`HmacSha384` | HS384
|`HmacSha512` | HS512
|`HmacSha256Signature` | http://www.w3.org/2001/04/xmldsig-more#hmac-sha256
|`HmacSha384Signature` | http://www.w3.org/2001/04/xmldsig-more#hmac-sha384
|`HmacSha512Signature` | http://www.w3.org/2001/04/xmldsig-more#hmac-sha512
|=======================
////

NOTE: Please check https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/wiki/Supported-Algorithms[Windows Documentation] to get the latest updates on supported encryption algorithms.

=== Setting up in devon
For setting it up using the Devon4NetApi template configure it in the `appsettings.{environment}.json` file. 

You will need to add a certificate that will be used for signing the token, please check the documentation about how to create a new certificate and add it to a project if you are not aware of how it's done.

Remember to configure your certificates in the JWT configuration.

Navigate to `Devon4Net.Application.WebAPI.Implementation.Business.AuthManagement.Controllers`. There you will find `AuthController` sample class which is responsible of generating the token thanks to login method.

[source, c#]
----
public AuthController(IJwtHandler jwtHandler)
{
    JwtHandler = jwtHandler;
}
----

You can see how the `IJwtHandler` is injected in the constructor via its interface, which allows you to use its methods.

In the following piece of code, you will find how the client token is created using a variety of claims. In this case this end-point will be available to not identified clients thanks to the `AllowAnonymous` attribute. The client will also have a sample role asigned, depending on which it will be able to access some end-points and not others. 
[source, c#]
----
[AllowAnonymous]
.
.
.
var token = JwtHandler.CreateClientToken(new List<Claim>
{
    new Claim(ClaimTypes.Role, AuthConst.DevonSampleUserRole),
    new Claim(ClaimTypes.Name,user),
    new Claim(ClaimTypes.NameIdentifier,Guid.NewGuid().ToString()),
});

return Ok(new LoginResponse { Token = token });
----

The following example will require clients to have the sample role to be able to use the end-point, thanks to the attribute `Authorize` with the `Roles` value specified. 

It also shows how you can obtain information directly from the token using the `JwtHandler` injection.
[source, c#]
----
[Authorize(AuthenticationSchemes = AuthConst.AuthenticationScheme, Roles = AuthConst.DevonSampleUserRole)]
.
.
.
//Get claims
var token = Request.Headers["Authorization"].ToString().Replace($"{AuthConst.AuthenticationScheme} ", string.Empty);
.
.
.
// Return result with claims values
var result = new CurrentUserResponse
{
    Id = JwtHandler.GetClaimValue(userClaims, ClaimTypes.NameIdentifier),
    UserName = JwtHandler.GetClaimValue(userClaims, ClaimTypes.Name),
    CorporateInfo = new List<CorporateBasicInfo> 
    { 
        new CorporateBasicInfo 
        { 
            Id = ClaimTypes.Role, 
            Value = JwtHandler.GetClaimValue(userClaims, ClaimTypes.Role) 
        } 
    }
};

return Ok(result);
----

NOTE: Please check devon documentation of Security and Roles to learn more about method attributtes.

=== Setting up in other projects
Install the package on your solution using the Package Manager Console:

[source, console]
----
> install-package Devon4Net.Infrastructure.JWT
----

Configure swagger in `Program.cs` adding the following lines:

[source, c#]
----
using Devon4Net.Application.WebAPI.Configuration;
.
.
.
builder.Services.SetupJwt(builder.Configuration);
----

At this moment you'll need to have at least one certificate added to your project.


NOTE: Please read the documentation of how to create and add certificates to a project.

Now we will configure the JWT component in `appsettings.{environment}.json` as shown in the next piece of code:

[source, json]
----
"JWT": {
    "Audience": "devon4Net",
    "Issuer": "devon4Net",
    "ValidateIssuerSigningKey": true,
    "ValidateLifetime": true,
    "RequireSignedTokens": true,
    "RequireExpirationTime": true,
    "RequireAudience": true,
    "ClockSkew": 5,
    "Security": {
      "SecretKeyLengthAlgorithm": "",
      "SecretKeyEncryptionAlgorithm": "",
      "SecretKey": "",
      "Certificate": "localhost.pfx",
      "CertificatePassword": "12345",
      "CertificateEncryptionAlgorithm": "HmacSha512",
      "RefreshTokenEncryptionAlgorithm": "Sha"
    }
  },
----

For using it, you will need a method that provides you a token. So lets create an `AuthController` controller and add those methods:
[source, c#]
----
[Route("api/[controller]")]
[ApiController]
public class AuthController : ControllerBase
{
    private readonly IJwtHandler _jwtHandler;

    public AuthController(IJwtHandler jwtHandler)
    {
        _jwtHandler = jwtHandler;
    }

    [HttpGet]
    [Route("/Auth")]
    [AllowAnonymous]
    public IActionResult GetToken()
    {
        var token = _jwtHandler.CreateClientToken(new List<Claim>
        {
            new Claim(ClaimTypes.Role, "MyRole"),
            new Claim(ClaimTypes.Name, "MyName"),
            new Claim(ClaimTypes.NameIdentifier, Guid.NewGuid().ToString()),
        });
        return Ok(token);
    }

    [HttpGet]
    [Route("/Auth/CheckToken")]
    [Authorize(AuthenticationSchemes = "Bearer", Roles = "MyRole")]
    public IActionResult CheckToken()
    {
        var token = Request.Headers["Authorization"].ToString().Replace($"Bearer ", string.Empty);
        var userClaims = _jwtHandler.GetUserClaims(token).ToList();
        var result = new 
        {
            Id = _jwtHandler.GetClaimValue(userClaims, ClaimTypes.NameIdentifier),
            UserName = _jwtHandler.GetClaimValue(token, ClaimTypes.Name),
            Role = _jwtHandler.GetClaimValue(userClaims, ClaimTypes.Role)
        };
        return Ok(result);
    }
}
----
Reading the code of this controller you have to take in mind a few things:

* `IJwtHandler` class is injected via dependency injection.

** `string CreateClientToken(List<Claim> list)` will allow you to create the token through a list of claims. The claims shown are hard-coded examples.

** `List<Claim> GetUserClaims(string token)` will allow you to get a list of claims given a token.

** `string GetClaimValue(List<Claim> list, string claim)` will allow you to get the value given the ClaimType and either a list of claims or a token thanks to the `string GetClaimValue(string token, string claim)` overload.

* `[AllowAnonymous]` attribute will allow access any client without authentication.

* `[Authorize(AuthenticationSchemes = "Bearer", Roles = "MyRole")]` attribute will allow any client authenticated with a bearer token and the role `"MyRole"`.


=== References

* https://docs.microsoft.com/en-us/dotnet/api/microsoft.identitymodel.tokens.tokenvalidationparameters?view=azure-dotnet[TokenValidationParameterClass - Microsoft Docs]

* https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/attributes/[Attributtes in C# - Microsoft Docs]

* https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/wiki/Supported-Algorithms[Algorithms supported]

== Devon4Net.Infrastructure.LiteDb
https://www.litedb.org/[LiteDb] is an open-source NoSQL embedded database for .NET. Is a document store inspired by MongoDB database. It stores data in documents, which are JSON objects containing key-value pairs. It uses BSON which is a Binary representation of JSON with additional type information.

One of the advantages of using this type of NoSQL database is that it allows the use of asynchronous programming techniques following ACID properties on its transactions. This properties are: Atomicity, Consistency, Isolation and Durability, and they ensure the highest possible data reliability and integrity. This means that you will be able to use `async/await` on your operations.

=== Configuration
The component configuration can be done in `appsettings.{environment}.json` with the following section:

[source, json]
----
"LiteDb": {
  "EnableLiteDb": true,
  "DatabaseLocation": "devon4net.db"
}
----
* `EnableLiteDb`: Boolean to activate the use of LiteDb.
* `DatabaseLocation`: Relative path of the file containing all the documents.

=== Setting up in devon
For setting it up using the Devon4Net WebApi template just configure it in the `appsettings.Development.json`.

Then you will need to inject the repositories. For that go to `Devon4Net.Application.WebAPI.Implementation.Configuration.DevonConfiguration` and add the folowing lines in `SetupDependencyInjection` method:

[source, c#]
----
using Devon4Net.Infrastructure.LiteDb.Repository;
.
.
.
services.AddTransient(typeof(IRepository<>), typeof(Repository<>));
---- 

Now you can use the `IRepository<T>` by injecting it wherever you want to use it. `T` will be the entity you will be working with in the repository.

[source, c#]
----
private readonly IRepository<Todo> _todoRepository;

public TodoController(IRepository<Todo> todoRepository)
{
    _todoRepository = todoRepository;
}
----


=== Setting up in other projects
For setting it up in other projects install it running the followin command in the Package Manager Console, or using the Package Manager in Visual Studio:

[source, console]
----
install-package Devon4Net.Infrastructure.LiteDb
----

Now set the configuration in the `appsettings.{enviroment}.json`:
[source, json]
----
"LiteDb": {
  "EnableLiteDb": true,
  "DatabaseLocation": "devon_database.db"
}
----

NOTE: Remember to set `EnableLiteDb` to `true`.

Navigate to your `Program.cs` file and add the following line to configure the component:

[source, c#]
----
using Devon4Net.Application.WebAPI.Configuration;
.
.
.
builder.Services.SetupLiteDb(builder.Configuration);
----

You will need also to add the repositories you will be using to your services, either by injecting the generic:

[source, c#]
----
builder.Services.AddTransient(typeof(IRepository<>), typeof(Repository<>));
----

Or by choosing to inject them one by one:

[source, c#]
----
builder.Services.AddTransient<IRepository<WeatherForecast>, Repository<WeatherForecast>>();
----

Now you will be able to use the repositories in your class using dependency injection, for example:

[source, c#]
----
[ApiController]
[Route("[controller]")]
public class WeatherForecastController : ControllerBase
{
    private readonly IRepository<WeatherForecast> _weatherForecastRepository;

    public WeatherForecastController(IRepository<WeatherForecast> weatherForecastRepository)
    {
        _weatherForecastRepository = weatherForecastRepository;
    }

    [HttpGet]
    public IEnumerable<WeatherForecast> Get()
    {
        return _weatherForecastRepository.Get();
    }

    [HttpPost]
    public IEnumerable<WeatherForecast> PostAndGetAll(WeatherForecast weatherForecast)
    {
        _weatherForecastRepository.Create(weatherForecast);
        return _weatherForecastRepository.Get();
    }
}
----